cassandra-tx
============

Provide transaction (atomicity, isolation), concurrent arithmetic functionality for cassandra.  This is standalone java library.
* non locking/blocking arithemtic operation increment, decrement on numeric column of a wide column family
* transaction scope for controlling columnfamily that need transaction (atomicity, isolation)
* Do not implement any isolation level


## Transaction
* Provide a snapshot/temp write while doing operation.  When commit, snapshot are copy to original.  When rollback, snapshot/temp tables are discarded.  snapshot/temp are readable by same session
```
Transaction Functions:
	List<Row> execute(String sql, Object... arguments);

	void commit();

	void rollback();
```
### Implementation
* dynamicly create temporary column family that is a copy with extra key for session at run time.  Reuse if the column family already exist.  This can be cumbersome if column family get changed.  Initialzation function can be added to detect if any temp table are out of date and delete and recreate them.
* Name of temp table : table_{checksum}, checksum is generated(using any hash algorithm) from columns name ( maximun 8 character)
* add extra columns to verify record is deleted


### Example
```
Context : is used to access and control transactions.  A context have a id which is autogenerated or user created.  context is transient.  The state of the context such as what are temporary written are saved in cassandra.

#Creating
ctx = Context.start() #new context	
#or want to use custom_id
ctx = Context.start(custom_id) #new context, if this id already exist, return error
#restart the application, or from another process
existingctx = Context.get_ctx(id) #access existing context, if doesn't exist, return error 	
ctx.commit() #context end, copy temp data to permanent
ctx.rollback() #context end, disregard temp data
ctx.execute(CQL) #write operation write to temp, read operation read from both temp and permanment with temp overlapping permanet
```

```
ctx = Context.start() #accessing/creating context.  there will be more ways to do it.
cust = select ... where id=1	#normal cql select
ctx.execute(update cust ... where id=1) #write to temp table of cust
ctx.execute(update cust ... where id=3) #create new customer write to temp table of cust
newcust = select ... where id = 3  #not visible via regular query yet, as it is in temp
ctx.execute('select ... where id = 3') #found, cust it is in same ctx/scope.  context knows about the temp table

ctx.commit() #merge temp table into main table for this context
select ... where id = 3  #now it is visible via regular query
```


## Arithmetic operation
Concurrent Increment/Decrement operation on columnfamily

For more detail on [implemention](README.md)
```


Require use of library to abstract incre/decre, merge, sum

Arithmetic Functions:
	incre(cf, key, amount, column) 
	decre(cf, key, amount, column)
	sum(cf, key, column)
	merge(cf, key, column)
```


###Getting started
#### Prerequisites
* First, you need java and git installed and in your user's PATH. 

####Get source
* $ git clone https://github.com/lunextelecom/cassandra-tx.git

#### Install
* mvn clean install -DskipTests=true

#### Running unit tests
* $ mvn test

#### Using cassandra-tx with IntelliJ IDEA
```
Importing cassandra-tx as a project in IDEA

The following instructions will import cassandra-tx as a new project in IntelliJ IDEA.

Open File > Import Project... and navigate to the cassandra-tx directory of your cassandra-tx clone 
Select Import project from external model, select "Maven", and click Next.
In the following screen, enable the checkbox Import Maven projects automatically. Leave all other values at their defaults. Click Next.
Click Next on the following screen about selecting Maven projects to import.
Select the JDK to be used by IDEA for cassandra-tx, then click Next.
At the time of this writing you should use JDK 7.

You may now optionally change the name of the project in IDEA. The default name suggested by IDEA is "cassandra-tx". Click Finish once you are done.
```

####Requirement
#####Arithmetic table must have follow construct
```
CREATE TABLE keyspacename.tablename
	(id int, updateid timeuuid, type text, version text, 
	 amount decimal, PRIMARY KEY (id, updateid, type, version)
	) WITH CLUSTERING ORDER BY (updateid DESC)

*updateid, type, version is required and managed by library
*table must be order by updateid(desc)
*partition keys can be single/compound column
*data must be inserted by library
*if partition keys is compound column, key must be a map when calling incre, sum, merge function

```
###How to use
####Transaction
```
//config node, port, original keyspace, temp keyspace(contains tmp table)
Configuration.loadConfig("localhost", 9042,"test_keyspace","tx_keyspace");
//start context
Context ctx = (Context) Context.start();
//insert
String sql = "insert into test_keyspace.customer(username, firstname, lastname, age) values(?,?,?,?)";
ctx.execute(sql, "trinhtran", "Trinh", "Tran", 20);
ctx.commit();//commit, copy data from tmp table to original table

//delete
sql = "delete from test_keyspace.customer where username = ?";
ctx.execute(sql, "trinhtran");
ctx.commit();

//update
sql = "update test_keyspace.customer set age = 26 where username = ?";
ctx.execute(sql, "duynguyen");

//select
sql = "select * from test_keyspace.customer where username = ?";
ctx.execute(sql, "duynguyen")
ctx.rollback();//disregard temp data
ctx.close();//disregard temp data & close context
```
####arithmetic function
#####key : single column
```
//config node, port, original keyspace, temp keyspace(contains tmp table)
Configuration.loadConfig("localhost", 9042,"test_keyspace","tx_keyspace");
Context ctx = (Context) Context.start();
int id = 123;
//increase
ctx.incre("seller_balance", id, "amount", new BigDecimal(1));

//sum
BigDecimal sum = ctx.sum("seller_balance", id, "amount");

//merge
ctx.merge("seller_balance", id, "amount");

ctx.close();
```

#####key : compound column
```
CREATE TABLE test_keyspace.seller_balance_complex 
	(company text, id int, 
	 updateid timeuuid,type text, version text, amount decimal,
	 PRIMARY KEY ((company, id), updateid, type, version )
	 ) WITH CLUSTERING ORDER BY (updateid DESC)
```
```
Context ctx = (Context) Context.start();
String table = "seller_balance_complex";
Map<String, Object> mapKey = new HashMap<String, Object>();
String company = "lunex";
int id = 123;
mapKey.put("company", company);
mapKey.put("id", id);
//increase
ctx.incre(table, mapKey, "amount", new BigDecimal(1));
//sum
BigDecimal sum = ctx.sum(table, mapKey, "amount");

ctx.close();//disregard temp data & close context
```
