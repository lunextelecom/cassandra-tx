cassandra-tx
============

Provide transaction (atomicity, isolation), concurrent arithmetic functionality for cassandra.  This is standalone java library.
* non locking/blocking arithemtic operation increment, decrement on numeric column of a wide column family
* transaction scope for controlling columnfamily that need transaction (atomicity, isolation)

## Transaction
Provide a snapshot/temp write while doing operation.  When commit, snapshot are copy to original.  When rollback, snapshot/temp tables are discarded.  snapshot/temp are readable by same session

### Implementation

#### Options
* dynamicly create temporary column family that is a copy with extra key for session at run time.  Reuse if the column family already exist.  This can be cumbersome if column family get changed.  Initialzation function can be added to detect if any temp table are out of date and delete and recreate them.
* save the temp data as binary or json and serialized each time.
* use compact storage to allow dynamic column

### Example
```
Context : is used to access and control transactions.  A context have a id which is autogenerated or user created.  context is transient.  The state of the context such as what are temporary written are saved in cassandra.

#Creating
ctx = Context.start() #new context	
#or want to use custom_id
ctx = Context.start(custom_id) #new context, if this id already exist, return error
#restart the application, or from another process
existingctx = Context.get_ctx(id) #access existing context, if doesn't exist, return error 	
ctx.commit() #context end, copy temp data to permanent
ctx.rollback() #context end, disregard temp data
ctx.execute(CQL) #write operation write to temp, read operation read from both temp and permanment with temp overlapping permanet
```

```
ctx = Context.start() #accessing/creating context.  there will be more ways to do it.
cust = select ... where id=1	#normal cql select
ctx.execute(update cust ... where id=1) #write to temp table of cust
ctx.execute(update cust ... where id=3) #create new customer write to temp table of cust
newcust = select ... where id = 3  #not visible via regular query yet, as it is in temp
ctx.execute('select ... where id = 3') #found, cust it is in same ctx/scope.  context knows about the temp table

ctx.commit() #merge temp table into main table for this context
select ... where id = 3  #now it is visible via regular query
```


## Arithemtic operation
Concurrent Increment/Decrement operation on columnfamily

### Implementation:
* Each Arithemtic operation insert a new column containing the value.
* To determine the value, must sum all columns for the row.
* Periodic merge of rows can be done to improve performance.
* Do not mix other field that are not necessary for arithemtic into this cf, eg. home address, name...
* The column family use wide row for the arithemtic field 
```
CREATE TABLE seller_balance (
	id bigint,
	tid timeuuid,
	amount decimal,
	PRIMARY KEY(id, updateid)
)
Require use of library to abstract incre/decre, merge, sum

Arithemtic Functions:
	incre(cf, key, amount, tid(optional)) #tid can be provide to avoid duplicate, otherwise, it will generate a timeuuid
	decre(cf, key, amount, tid(optional))
	sum(cf, key)
	merge(cf, key)
```

###Example
```
Current balance of 30 			
cf = "seller_balance"
id = ('lunex', 123) #for example, id can be a tuple
incre(cf, id, 5)
incre(cf, id, 10)			
incre(cf, id, 15) #balance = [5, 10, 15]			
sum(cf, id) = 30
incre(cf, id, 3) #balance = [5, 10, 15, 3]	
sum(cf, id) = 33
merge(cf, id) = 33 # [33]

```
Arithmetic with Transaction
```
ctx = Context.start()
id = 3
bal = sum(cf, id) #let's say balance is 10
ctx.incre(cf, id, 5) #visible only by context seller_balance = [10] seller_balance_temp = [5]
incre(cf, id, 1) #seller_balance = [10, 1] seller_balance_temp = [5]
sum(cf, id) #15
ctx.sum(cf, id) #20 , include the seller_temp
ctx.commit() #ctx.merge get called.
sum(cf, id) #20

#let's do a rollback
ctx = Context.start()
ctx.incre(cf, 5) #visible only by context seller.balance = [20] seller_temp.balance = [5]
ctx.rollback() #ctx.close(), all temp item with ctx is removed
sum(cf, id) #20
```



