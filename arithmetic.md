Algorithm for Arithmetic
===================
Arithmetic operations is non blocking and it is optimized for update rather than reading.  When an account is incremented, no value are change, only new record are added.  Many records can then be merge back into a single row.  For system that require alot of reading, it is recommend to cache the number.  For high volume system, the number is always changing so any number you get is outdated by the time it reach the client.

####Simple Example:
```
[1]     --Incre 3-->    [1,3]
[1,3]   --Incre 5-->    [1,3,5]
[1,3,5] --Sum    -->    9
[1,3,5] --Merge  -->    [9]
```

###Goal: 
* There will be more incre/decre than merge.  It make sense to make incre/decre as fast as possible. 
* Multiple threads/processs can call merge, incre, decre at the same time.
* Failed operation midpoint must not cause corrupted data
* Works with Transaction Context.

### Implementation
##### incre/decre: single record insert
  1. (cassandra operation) insert records

##### merge:
  1. (cassandra operation) normal_rows, tombstone_rows, merge_rows = get rows for sum
  2. (local code) discard invalid tombstone_rows, invalid_merge rows,  get lastest updateid
  3. (local code) sum = normal_rows + valid_tombstone_rows + valid_merge_rows
  4. (local code) newversion = generate timeuuid
  5. (cassandra operation) if last record is a merge, skip. insert tombstone for normal + merged rows with newversion. 
  6. (cassandra operation) if previous step is skip, skip this one too. insert merge record with sum and newversion and updateid = lastest updateid,  this operation make tombstone valid
  7. (cassandra operation, sometimes) delete normal and merge records with valid tombstone.  Do not send this request if there isn't any records to delete.
  8. (cassandra operation, sometimes) delete invalid tombstone, invalid merge older than 10 mins if there are any, do not send this request if there isnt' any match

##### sum: single wide row read 
  1. normal_rows, tombstone_rows, merge_rows = get rows for sum
  2. discard invalid tombstone_rows, invalid_merge rows
  3. sum = normal_rows + valid_tombstone_rows + valid_merge_rows

### Example and usage
```
CREATE TABLE seller_balance (    
    id int,   
    updateid timeuuid,
    type int, 
    version text,    
    amount decimal,
    PRIMARY KEY (id, updateid, type, version )
) WITH CLUSTERING ORDER BY (updateid DESC);

The following columns are required and managed by the library

type:
    N: normal record generated by incre/decre
    S: merge record generated by merge.  this is the sum record. A merge record is valid if there are no other merge record have updateid greated than it.
    T: tombstone record.  A tombstone record is valid if its version matches a version that is a merge record and a updateid that matches a normal or merge record.  A valid tombstone record cancel out normal or merge record with the updateid.  A invalid tombstone record is one which there is no merge record with the same version or no normal record with same updateid.  Invalid tombstone have zero value and is not counted during sum.

updateid:
    this is timeuuid generated by cassandra.  Do not generated this in library code.

version:
    it is generated when merge record is inserted.  Only merge and tombstone record require a version to correlate their existence. Normal record can use empty string.  use a uuid string for version, to avoid having to version clash.

Example:
let's represent the table as a tuple (updateid,type,version,value) so a wide row for a seller would look like
[tuple,tuple...]
for easy to read, a int value is used instead of timeuuid for updateid and version

sum is 6 for these 2 normal record
[(0,N,,1),(2,N,,5)]

****Start  test_merge
: Start Merge 1
: mem: [(0, 'N', , 1), (1, 'N', , 5)]
: cas: [(0, 'N', , 1), (1, 'N', , 5)]
: After insert tombstone 
: mem: [(0, 'N', , 1), (1, 'N', , 5)]
: cas: [(0, 'N', , 1), (0, 'T', 1, 1), (1, 'N', , 5), (1, 'T', 1, 5)]
: 6 = + 1 + 5
: After insert merge [(2, 'S', 1, 6)]
: mem: [(0, 'N', , 1), (1, 'N', , 5)]
: cas: [(0, 'N', , 1), (0, 'T', 1, 1), (1, 'N', , 5), (1, 'T', 1, 5), (2, 'S', 1, 6)]
: Skip delete normal, merge with valid tombstone
: Skip delete invalid, nothing to delete
: Complete Merge 1

: Start Merge 2
: mem: [(0, 'N', , 1), (0, 'T', 1, 1), (1, 'N', , 5), (1, 'T', 1, 5), (2, 'S', 1, 6)]
: cas: [(0, 'N', , 1), (0, 'T', 1, 1), (1, 'N', , 5), (1, 'T', 1, 5), (2, 'S', 1, 6)]
: Skip insert tombstone because no new record inserted
: After delete normal, merge with valid tombstone [(0, 'N', , 1), (1, 'N', , 5)]
: mem: [(0, 'N', , 1), (0, 'T', 1, 1), (1, 'N', , 5), (1, 'T', 1, 5), (2, 'S', 1, 6)]
: cas: [(0, 'T', 1, 1), (1, 'T', 1, 5), (2, 'S', 1, 6)]
: Skip delete invalid, nothing to delete
: Complete Merge 2

: Start Merge 3
: mem: [(0, 'T', 1, 1), (1, 'T', 1, 5), (2, 'S', 1, 6)]
: cas: [(0, 'T', 1, 1), (1, 'T', 1, 5), (2, 'S', 1, 6)]
: Skip insert tombstone because no new record inserted
: Skip delete normal, merge with valid tombstone
: After delete invalid tombstone [(0, 'T', 1, 1)]
: Some invalid tombstone [(1, 'T', 1, 5)] are skipped because they are not old enough
: mem: [(0, 'T', 1, 1), (1, 'T', 1, 5), (2, 'S', 1, 6)]
: cas: [(1, 'T', 1, 5), (2, 'S', 1, 6)]
: Complete Merge 3

: Start Merge 4
: mem: [(1, 'T', 1, 5), (2, 'S', 1, 6)]
: cas: [(1, 'T', 1, 5), (2, 'S', 1, 6)]
: Skip insert tombstone because no new record inserted
: Skip delete normal, merge with valid tombstone
: After delete invalid tombstone [(1, 'T', 1, 5)]
: mem: [(1, 'T', 1, 5), (2, 'S', 1, 6)]
: cas: [(2, 'S', 1, 6)]
: Complete Merge 4


```


###Test Case:
merge and incre is called at the same time
```
    incre begin
    merge begin
    incre finish
    merge finish

    merge begin
    incre begin
    merge finish
    incre finish

    merge begin
    incre begin
    incre finish
    merge finish

    incre begin
    merge begin 
    merge finish
    incre finish
```
merge called by 2 thread
```    
    merge1 begin
    merge2 begin
    merge2 end
    merge1 end

    merge1 begin
    merge2 begin    
    merge1 end  
    merge2 end
```
