Algorithm for Arithmetic
===================
Arithmetic operations is non blocking and it is optimized for update rather than reading.  When an account is incremented, no value are change, only new record are added.  Many records can then be merge back into a single row.  For system that require alot of reading, it is recommend to cache the number.  For high volume system, the number is always changing so any number you get is outdated by the time it reach the client.

####Simple Example:
```
[1]     --Incre 3-->    [1,3]
[1,3]   --Incre 5-->    [1,3,5]
[1,3,5] --Sum    -->    9
[1,3,5] --Merge  -->    [9]
```

###Goal: 
* There will be more incre/decre than merge.  It make sense to make incre/decre as fast as possible. 
* Multiple threads/processs can call merge, incre, decre at the same time.
* Failed operation midpoint must not cause corrupted data
* Works with Transaction Context.

### Implementation
##### incre/decre: single record insert
  1. (cassandra operation) insert records

##### merge:
  1. (cassandra operation) normal_rows, tombstone_rows, merge_rows = get rows for sum
  2. (local code) discard invalid tombstone_rows 
  3. (local code) sum = normal_rows + valid_tombstone_rows + merge_rows
  4. (local code) newversion = generate timeuuid
  5. (cassandra operation) insert tombstone for normal + merged rows with newversion
  6. (cassandra operation) insert merge record with sum and newversion.  this operation make tombstone valid
  7. (cassandra operation, sometimes) delete normal and merge records with valid tombstone.  Do not send this request if there isn't any records to delete.
  8. (cassandra operation, sometimes) delete invalid tombstone older than 10 mins if there are any, do not send this request if there isnt' any match

##### sum: single wide row read 
  1. normal_rows, tombstone_rows, merge_rows = get rows for sum
  2. discard invalid tombstone_rows 
  3. sum = normal_rows + valid_tombstone_rows + merge_rows

### Example and usage
```
CREATE TABLE seller_balance (    
    id int,   
    updateid timeuuid,
    type int, 
    version text,    
    amount decimal,
    PRIMARY KEY (id, updateid, type, version )
) WITH CLUSTERING ORDER BY (updateid DESC);

The following columns are required and managed by the library

type:
    N: normal record generated by incre/decre
    S: merge record generated by merge.  this is the sum record
    T: tombstone record.  A tombstone record is valid if its version matches a version that is a merge record and a updateid that matches a normal or merge record.  A valid tombstone record cancel out normal or merge record with the updateid.  A invalid tombstone record is one which there is no merge record with the same version or no normal record with same updateid.  Invalid tombstone have zero value and is not counted during sum.

updateid:
    this is timeuuid generated by cassandra.  Do not generated this in library code.

version:
    it is generated when merge record is inserted.  Only merge and tombstone record require a version to correlate their existence. Normal record can use empty string.  use a uuid string for version, to avoid having to version clash.

Example:
let's represent the table as a tuple (updateid,type,version,value) so a wide row for a seller would look like
[tuple,tuple...]
for easy to read, a int value is used instead of timeuuid for updateid and version

sum is 9 for these 3 normal record
[(0,N,,1),(1,N,,3),(2,N,,5)]

merge generate version=1 insert tombstone
tombstone record is invalid since it doesnt' have a matching version merge
sum is still 9 by adding the normal records.  invalid tombstone is not counted.
[(0,N,,1),(0,T,1,1),(1,N,,3),(1,T,1,3),(2,N,,5),(2,T,1,5)]

merge record is inserted.  tombstone record become valid and cancel out the normals
1 - 1 + 3 - 3 + 5 - 5 + 9(merge)
[(0,N,,1),(0,T,1,1),(1,N,,3),(1,T,1,3),(2,N,,5),(2,T,1,5),(3,S,1,9)] 

delete normal, merge records that have valid tombstone
[(0,T,1,1),(1,T,1,3),(2,T,1,5),(3,S,1,9)] 

delete invalid tombstone
[(3,S,1,9)] 

insert 1
sum is now 10
[(3,S,1,9),(4,N,,1)] 

sum is still 10
9 + 1 = 10
[(3,S,1,9),(3,T,1,9),(4,N,,1),(4,T,2,1)] 

merge insert, tombstone is now valid
9 - 9 + 1 + 1 + 10
[(3,S,1,9),(3,T,2,9),(4,N,,1),(4,T,2,1),(4,S,2,10)] 


```


###Test Case:
merge and incre is called at the same time
```
    incre begin
    merge begin
    incre finish
    merge finish

    merge begin
    incre begin
    merge finish
    incre finish

    merge begin
    incre begin
    incre finish
    merge finish

    incre begin
    merge begin 
    merge finish
    incre finish
```
merge called by 2 thread
```    
    merge1 begin
    merge2 begin
    merge2 end
    merge1 end

    merge1 begin
    merge2 begin    
    merge1 end  
    merge2 end
```
